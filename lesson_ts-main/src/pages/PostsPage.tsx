// Импорт необходимых модулей и компонентов React
import React, { useEffect, useMemo, useState } from "react";
// Импорт главного layout компонента для структуры страницы
import MainLayoute from "../layouts/MainLayoute";
// Импорт хуков Redux для работы с состоянием
import { useDispatch, useSelector } from "react-redux";
// Импорт типа AppDispatch для типизации dispatch
import type { AppDispatch } from "../store/store";
// Импорт действий и селекторов для работы с постами
import {
    fetchPosts,           // действие для загрузки постов
    addPost,              // действие для добавления нового поста
    updatePost,           // действие для обновления существующего поста
    deletePost,           // действие для удаления поста
    clearPostsError,      // действие для очистки ошибок постов
    selectPosts,          // селектор для получения всех постов
    selectPostsLoading,   // селектор для получения статуса загрузки
    selectPostsError,     // селектор для получения ошибок
    setEditingId,         // действие для установки ID редактируемого поста
    selectEditingId       // селектор для получения ID редактируемого поста
} from "../store/slices/postsSlice";
// Импорт типа Post для типизации данных поста
import type { Post } from "../shared/types/Post";
// Импорт функции для разрешения URL изображения поста
import { resolvePostImage } from "../api/postsApi";
// Импорт SCSS стилей для компонента постов
import "../styles/components/posts.scss";

// Определение пустой формы для инициализации состояния
const emptyForm = {
    title: "",           // заголовок поста
    content: "",         // содержимое поста
    author: "",          // автор поста
    imageUrl: "" as string,  // URL изображения (строка)
    imageFile: null as File | null  // файл изображения (File или null)
};

// Определение функционального компонента PostsPage с типизацией React.FC
const PostsPage: React.FC = () => {
    // Инициализация dispatch с типом AppDispatch для работы с Redux
    const dispatch = useDispatch<AppDispatch>();
    // Получение списка постов через селектор
    const posts = useSelector(selectPosts);
    // Получение статуса загрузки через селектор
    const loading = useSelector(selectPostsLoading);
    // Получение ошибки через селектор
    const error = useSelector(selectPostsError);
    // Получение ID редактируемого поста через селектор
    const editingId = useSelector(selectEditingId);

    // Состояние формы с данными поста
    const [form, setForm] = useState(emptyForm);
    // Состояние для предпросмотра изображения
    const [preview, setPreview] = useState<string | undefined>(undefined);

    // Эффект для загрузки постов при монтировании компонента
    useEffect(() => {
        dispatch(fetchPosts());
    }, [dispatch]); // Зависимость от dispatch

    // Эффект для заполнения формы данными при входе в режим редактирования
    useEffect(() => {
        // Если нет ID редактирования, выходим
        if (!editingId) return;
        // Находим пост по ID
        const p = posts.find(x => x.id === editingId);
        // Если пост не найден, выходим
        if (!p) return;
        // Заполняем форму данными найденного поста
        setForm({
            title: p.title,
            content: p.content,
            author: p.author,
            imageUrl: p.image_url ?? "",  // используем пустую строку если null
            imageFile: null
        });
        // Устанавливаем предпросмотр изображения
        setPreview(resolvePostImage(p));
    }, [editingId, posts]); // Зависимости от editingId и posts

    // Мемоизированная проверка возможности отправки формы
    const canSubmit = useMemo(() =>
        // Форма может быть отправлена если все обязательные поля заполнены
        form.title.trim() && form.content.trim() && form.author.trim(),
        [form] // Зависимость от формы
    );

    // Обработчик изменения файла изображения
    const onFileChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
        // Получаем первый файл из input или null
        const f = e.target.files?.[0] || null;
        // Обновляем форму с новым файлом
        setForm(v => ({ ...v, imageFile: f }));
        // Если файл выбран
        if (f) {
            // Создаем URL для предпросмотра
            const url = URL.createObjectURL(f);
            setPreview(url);
        } else {
            // Если файл не выбран, используем URL из формы
            setPreview(form.imageUrl || undefined);
        }
    };

    // Обработчик изменения URL изображения
    const onImageUrlChange = (v: string) => {
        // Обновляем форму с новым URL и сбрасываем файл
        setForm(s => ({ ...s, imageUrl: v, imageFile: null }));
        // Устанавливаем предпросмотр
        setPreview(v || undefined);
    };

    // Функция сброса формы к начальному состоянию
    const resetForm = () => {
        setForm(emptyForm);           // сбрасываем форму
        setPreview(undefined);        // сбрасываем предпросмотр
        dispatch(setEditingId(null)); // выходим из режима редактирования
    };

    // Обработчик отправки формы
    const handleSubmit = async () => {
        // Если форма не может быть отправлена, выходим
        if (!canSubmit) return;
        try {
            // Если редактируем существующий пост
            if (editingId) {
                // Если есть файл изображения для обновления
                if (form.imageFile) {
                    // Отправляем обновление с файлом
                    await dispatch(updatePost({ id: editingId, imageFile: form.imageFile })).unwrap();
                }
                // Отправляем обновление данных поста
                await dispatch(updatePost({
                    id: editingId,
                    patch: {
                        title: form.title.trim(),
                        content: form.content.trim(),
                        author: form.author.trim(),
                        image_url: form.imageUrl || null
                    }
                })).unwrap();
            } else {
                // Создаем новый пост
                await dispatch(addPost({
                    title: form.title.trim(),
                    content: form.content.trim(),
                    author: form.author.trim(),
                    imageUrl: form.imageUrl || undefined,
                    imageFile: form.imageFile
                })).unwrap();
            }
            // Сбрасываем форму после успешной отправки
            resetForm();
        } catch {
            // Ошибка уже обработана в state.error
            /* ошибка уже в state.error */
        }
    };

    // Функция начала редактирования поста
    const startEdit = (p: Post) => dispatch(setEditingId(p.id));

    // Обработчик удаления поста
    const handleDelete = async (id: string) => {
        // Подтверждение удаления
        if (!confirm("Удалить пост?")) return;
        try {
            // Отправляем запрос на удаление
            await dispatch(deletePost(id)).unwrap();
        }
        catch {
            // Ошибка уже обработана в state.error
            /* ошибка уже в state.error */
        }
    };

    // Возвращаем JSX разметку компонента
    return (
        <MainLayoute>
            <div className="container">
                <h1 className="page-title">Посты</h1>

                {/* Блок отображения ошибки */}
                {error && (
                    <p className="error">
                        Ошибка: {error}{" "}
                        {/* Кнопка очистки ошибки */}
                        <button className="btn btn--ghost" onClick={() => dispatch(clearPostsError())}>
                            очистить
                        </button>
                    </p>
                )}

                {/* Форма создания/редактирования поста */}
                <div className="post-form">
                    <div className="inputs">
                        {/* Поле ввода заголовка */}
                        <input className="input" placeholder="Заголовок" value={form.title}
                            onChange={(e) => setForm(s => ({ ...s, title: e.target.value }))} />
                        {/* Поле ввода автора */}
                        <input className="input" placeholder="Автор" value={form.author}
                            onChange={(e) => setForm(s => ({ ...s, author: e.target.value }))} />
                        {/* Текстовое поле для содержимого */}
                        <textarea className="input" placeholder="Текст" rows={4} value={form.content}
                            onChange={(e) => setForm(s => ({ ...s, content: e.target.value }))} />
                        {/* Поле ввода URL изображения */}
                        <input className="input" placeholder="Картинка (URL)"
                            value={form.imageUrl} onChange={(e) => onImageUrlChange(e.target.value)} />
                        {/* Поле выбора файла изображения */}
                        <div className="file">
                            <input type="file" id="post-file" accept="image/*" onChange={onFileChange} />
                        </div>
                    </div>

                    {/* Блок действий с формой */}
                    <div className="actions">
                        {/* Кнопка сброса формы */}
                        <button className="btn" onClick={resetForm} disabled={loading}>
                            Сброс
                        </button>
                        {/* Кнопка отправки формы */}
                        <button className="btn btn--primary" onClick={handleSubmit} disabled={!canSubmit || loading}>
                            {editingId ? (loading ? "Сохранение..." : "Сохранить") : (loading ? "Добавление..." : "Добавить")}
                        </button>
                    </div>

                    {/* Блок предпросмотра изображения */}
                    {preview && (
                        <div className="preview">
                            <img src={preview} alt="preview" />
                        </div>
                    )}
                </div>

                {/* Сетка с постами */}
                <div className="posts-grid">
                    {/* Отображение списка постов */}
                    {posts.map(p => {
                        // Получаем URL изображения для поста
                        const img = resolvePostImage(p);
                        return (
                            // Карточка поста
                            <article className="post-card" key={p.id}>
                                {/* Изображение поста если есть */}
                                {img && <img className="post-img" src={img} alt={p.title} />}
                                {/* Тело карточки */}
                                <div className="post-body">
                                    {/* Заголовок поста */}
                                    <h3 className="post-title">{p.title}</h3>
                                    {/* Мета-информация об авторе */}
                                    <div className="post-meta">Автор: {p.author}</div>
                                    {/* Содержимое поста */}
                                    <p className="post-text">{p.content}</p>
                                </div>
                                {/* Блок действий с постом */}
                                <div className="post-actions">
                                    {/* Кнопка редактирования */}
                                    <button className="btn" onClick={() => startEdit(p)} disabled={loading}>
                                        Редактировать
                                    </button>
                                    {/* Кнопка удаления */}
                                    <button className="btn" onClick={() => handleDelete(p.id)} disabled={loading}>
                                        Удалить
                                    </button>
                                </div>
                            </article>
                        );
                    })}
                </div>
            </div>
        </MainLayoute>
    );
};

// Экспорт компонента по умолчанию
export default PostsPage;

/*
===========================================
ПОЯСНЕНИЯ К КОММЕНТАРИЯМ В ДАННОМ ФАЙЛЕ:
===========================================

1. Файл PostsPage.tsx - React компонент страницы управления постами

2. Комментарий "Импорт необходимых модулей и компонентов React" - описывает
   базовые импорты React и его хуков (useEffect, useMemo, useState)

3. Комментарий "Импорт главного layout компонента..." - поясняет
   использование компонента макета страницы MainLayoute

4. Комментарий "Импорт хуков Redux для работы с состоянием" - описывает
   использование useDispatch и useSelector для управления состоянием

5. Комментарий "Импорт типа AppDispatch для типизации dispatch" - объясняет
   необходимость типизации для TypeScript

6. Комментарий "Импорт действий и селекторов для работы с постами" - перечисляет
   все импортируемые действия и селекторы из postsSlice с пояснениями

7. Комментарий "Импорт типа Post для типизации данных поста" - описывает
   импорт кастомного типа для строгой типизации

8. Комментарий "Импорт функции для разрешения URL изображения поста" - поясняет
   назначение функции resolvePostImage

9. Комментарий "Импорт SCSS стилей для компонента постов" - поясняет
   подключение стилей для компонента

10. Комментарий "Определение пустой формы для инициализации состояния" - описывает
    структуру начального состояния формы

11. Комментарий "Инициализация dispatch с типом AppDispatch..." - объясняет
    типизацию dispatch для Redux

12. Комментарий "Получение списка постов через селектор" - описывает
    получение данных из Redux store

13. Комментарий "Состояние формы с данными поста" - поясняет
    использование useState для управления формой

14. Комментарий "Состояние для предпросмотра изображения" - описывает
    хранение URL для предпросмотра изображения

15. Комментарий "Эффект для загрузки постов при монтировании компонента" - объясняет
    загрузку данных при первом рендере

16. Комментарий "Эффект для заполнения формы данными при входе в режим редактирования" - описывает
    логику предзаполнения формы при редактировании

17. Комментарий "Мемоизированная проверка возможности отправки формы" - поясняет
    использование useMemo для оптимизации проверки

18. Комментарий "Обработчик изменения файла изображения" - описывает
    логику работы с файлами изображений

19. Комментарий "Обработчик изменения URL изображения" - объясняет
    синхронизацию URL и предпросмотра

20. Комментарий "Функция сброса формы к начальному состоянию" - описывает
    очистку формы и выхода из режима редактирования

21. Комментарий "Обработчик отправки формы" - подробно объясняет
    логику создания и обновления постов

22. Комментарий "Функция начала редактирования поста" - описывает
    установку ID редактируемого поста

23. Комментарий "Обработчик удаления поста" - поясняет
    логику удаления с подтверждением

24. Комментарий "Блок отображения ошибки" - описывает
    условный рендеринг блока с ошибкой

25. Комментарий "Форма создания/редактирования поста" - маркирует
    начало формы управления постом

26. Комментарий "Поле ввода заголовка" - описывает
    элемент управления для заголовка поста

27. Комментарий "Поле ввода автора" - описывает
    элемент управления для автора поста

28. Комментарий "Текстовое поле для содержимого" - поясняет
    элемент для основного текста поста

29. Комментарий "Поле ввода URL изображения" - описывает
    элемент для ссылки на изображение

30. Комментарий "Поле выбора файла изображения" - объясняет
    элемент загрузки файла изображения

31. Комментарий "Блок действий с формой" - маркирует
    кнопки управления формой

32. Комментарий "Кнопка сброса формы" - описывает
    функционал кнопки сброса

33. Комментарий "Кнопка отправки формы" - поясняет
    адаптивный текст кнопки в зависимости от режима

34. Комментарий "Блок предпросмотра изображения" - описывает
    отображение предпросмотра изображения

35. Комментарий "Сетка с постами" - маркирует
    начало блока с карточками постов

36. Комментарий "Отображение списка постов" - описывает
    маппинг массива постов в карточки

37. Комментарий "Карточка поста" - маркирует
    отдельный элемент поста

38. Комментарий "Изображение поста если есть" - описывает
    условный рендеринг изображения

39. Комментарий "Тело карточки" - маркирует
    контентную часть карточки

40. Комментарий "Заголовок поста" - описывает
    отображение заголовка

41. Комментарий "Мета-информация об авторе" - поясняет
    отображение информации об авторе

42. Комментарий "Содержимое поста" - описывает
    отображение основного текста

43. Комментарий "Блок действий с постом" - маркирует
    кнопки управления постом

44. Комментарий "Кнопка редактирования" - описывает
    функционал кнопки редактирования

45. Комментарий "Кнопка удаления" - описывает
    функционал кнопки удаления

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:

- Управление состоянием формы для создания и редактирования постов
- Поддержка загрузки изображений как по URL, так и через файлы
- Предпросмотр изображений перед отправкой
- Валидация обязательных полей формы
- Обработка различных состояний загрузки
- Подтверждение удаления постов
- Адаптивные тексты кнопок в зависимости от режима

СТРУКТУРА КОМПОНЕНТА:

- Заголовок страницы
- Блок отображения ошибок
- Форма управления постом
- Сетка с карточками постов
- Интерактивные элементы управления для каждого поста

ИСПОЛЬЗОВАНИЕ:
- Страница управления постами в блоге или CMS системе
- Создание, редактирование и удаление постов
- Управление изображениями постов
- Визуальное отображение контента
- Интеграция с Redux store для состояния постов
*/